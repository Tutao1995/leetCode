# 数组排序

### 概念

对一序列对象根据某个关键字进行排序

### 时间复杂度

一个算法执行所耗费的时间

### 空间复杂度

运行完一个程序所需内存的大小

### 常见算法

| 算法     | 时间复杂度 | 最好情况   | 最坏情况 | 空间复杂度 | 稳定性 |
| :------- | :--------- | :--------- | :------- | :--------- | :----- |
| 快速排序 | O(n log n) | O(n log n) | O(n2)    | O(log n)   | 不稳定 |
| 冒泡排序 | O(n2)      | O(n2)      | O(n2)    | O(1)       | 稳定   |
| 选择排序 | O(n2)      | O(n2)      | O(n2)    | O(1)       | 不稳定 |
| 插入排序 | O(n2)      | O(n )      | O(n2)    | O(1)       | 稳定   |

### 快速排序

-   从数列中挑出一个元素，称为 "基准"（pivot）；
-   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
-   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 冒泡排序

-   比较相邻的元素。如果第一个比第二个大，就交换它们两个；
-   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
-   针对所有的元素重复以上的步骤，除了最后一个；
-   重复步骤 1~3，直到排序完成。

### 选择排序

-   初始状态：无序区为 R[1..n]，有序区为空；
-   第 i 趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为 R[1..i-1]和 R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i]和 R[i+1..n)分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；
-   n-1 趟结束，数组有序化了。

### 插入排序

-   从第一个元素开始，该元素可以认为已经被排序；
-   取出下一个元素，在已经排序的元素序列中从后向前扫描；
-   如果该元素（已排序）大于新元素，将该元素移到下一位置；
-   重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
-   将新元素插入到该位置后；
-   重复步骤 2~5。
